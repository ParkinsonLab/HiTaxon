import argparse
import numpy as np
import pandas as pd
import fasttext as ft
import os

from Bio import SeqIO
from ete3 import NCBITaxa
from HiTaxon.evaluation_utils import fasta2kmer

def kaiju_HiTaxon_evaluation(sequence_file, report_path, report_name, model_path, min_threshold = 0.5):
    """
    Generate species-level ML predictions using Kaiju genus classifications
    Args:
        sequence_file: file path of k-merized FASTA 
        report_path: path in which Kaiju output is saved
        report_name: pre-fix name of output file
        model_path: path in which trained models are located
    """

    #Create tuple of sequences and position for k-merized FASTA file
    evaluation_file = open(f"{report_path}/{report_name}_kmer.txt", "r")
    counter = 0
    seqs = []
    for sequence in evaluation_file:
            seqs.append((sequence[:-1], counter))
            counter += 1
    
    ranks = ['phylum', 'class', 'order', 'family', 'genus', "species"]
    model_preds = np.zeros(shape = (counter, 6))
    model_preds = pd.DataFrame(model_preds, columns = ranks)

    #Generate predictions for only those genera in which trained classifiers are present
    trained_genus = [model.split("_")[0] for model in os.listdir(model_path)]
    reference = pd.read_csv(f"{report_path}/{report_name}_lineage_kaiju.csv")
    reference["genus"] = reference["genus"].apply(lambda x: x if x in trained_genus else "nan")
    model_preds["genus"] = reference["genus"]
    
    #Create dictionary with structure: {Prediction1 => [(Kaiju_Prediction, position in FASTA) ... (Kaiju_Prediction, position in FASTA)], Prediction2 => [(Kaiju_Prediction, position in FASTA) ... (Kaiju_Prediction, position in FASTA)] }
    genus_preds_dict = {}
    position = 0
    for genus in model_preds["genus"].values:
        pred = genus
        if not(pred in genus_preds_dict.keys()):
            genus_preds_dict[pred] = []
        genus_preds_dict[pred].append((pred, position))
        position +=1

    #Create list of precictons with structure: => [(prediction, score, position in FASTA)...(prediction, score, position in FASTA)]
    pred_tracker = []
    for genus, seq_list in genus_preds_dict.items():
        if str(genus) == "nan":
            for seq in seq_list:
                pred = "NA"
                score = 0.49
                pred_tracker.append((pred, score, seq[1]))
            continue
        else:
            model = ft.load_model(f"{model_path}/{genus}_model.bin")
            for seq in seq_list:
                model_prediction = model.predict(seqs[seq[1]][0])
                pred = model_prediction[0][0].split("label__")[1]
                score = model_prediction[1][0]
                pred_tracker.append((pred, score, seq[1]))
    #Resort predictions based on original position in FASTA
    pred_tracker = sorted(pred_tracker, key = lambda model_output: model_output[2])
    species_pred = []
    #Keep predictions which meet the minimum threshold
    for model_output in pred_tracker:
        if model_output[1] >= min_threshold:
            species_pred.append(model_output[0])
        else:
            species_pred.append("NA")
    model_preds["species"] = species_pred
    return model_preds


def kaiju_HiTaxon_ensemble(report_path, report_name):
    """
    Ensemble 1) Species predictions generated by ML models using Kaiju's genus classifications and 2) Kaiju's species predictions
    Args:
        report_path: path in which Kaiju-informed ML and Kaiju outputs are saved
        report_name: pre-fix name used for Kaiju-informed ML and Kaiju outputs
    """
    ml_species = pd.read_csv(f"{report_path}/{report_name}_ml.csv")
    reference = pd.read_csv(f"{report_path}/{report_name}_lineage_kaiju.csv")
    ensemble_preds = []
    for i in range(0, len(reference)):
        #If Kaiju has no genus predictions, ensemble leaves species unclassified
        if str(reference["genus"].iloc[i]) == "nan":
            ensemble_preds.append("nan")
        #IF ML model has no species prediction, ensemble uses Kaiju prediction
        elif str(ml_species["species"].iloc[i]) == "nan":
            ensemble_preds.append(reference["species"].iloc[i])
        #By default, uses ML predictions
        else:
            ensemble_preds.append(str(ml_species["species"].iloc[i]))
    ensemble_preds = [str(i).replace(" ","_") for i in ensemble_preds]
    reference["species"] = ensemble_preds
    return reference

"""
Generate Kaiju-HiTaxon-Ens classifier

"""
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("report_path", type = str, help = "path in which Kaiju-ML and Kaiju outputs are saved")
    parser.add_argument("report_name", type = str, help = "pre-fix name used for Kaiju-ML and Kaiju outputs")
    parser.add_argument("sequence_file", type = str, help = "file path of k-merized FASTA ")
    parser.add_argument("model_path", type = str, help = "path in which trained models are located")
    args = parser.parse_args()

    report_path = args.report_path
    report_name = args.report_name
    sequence_file = args.sequence_file
    model_path = args.model_path

    ncbi = NCBITaxa()
    #K-merize FASTA
    fasta2kmer(sequence_file, report_path, report_name)

    #Generate species-level predictions with ML models
    ml_output = evaluation(sequence_file, report_path, report_name, model_path)
    ml_output.to_csv(f"{report_path}/{report_name}kaiju_ml.csv")
    #Ensemble ML outputs with Kaiju outputs
    ensemble_output = ensemble(report_path, report_name)
    ensemble_output.to_csv(f"{report_path}/{report_name}_kaiju_HiTaxon.csv")

if __name__ == "__main__":
    main()
